[
  {
    "objectID": "NOTES/Programming-notes_Named-and-position-arguments.html",
    "href": "NOTES/Programming-notes_Named-and-position-arguments.html",
    "title": "Named and positional arguments",
    "section": "",
    "text": "library(palmerpenguins)\nlibrary(ggplot2)\n\nConsider the following code we use to create a scatterplot from the penguin data:\n\nggplot(data = penguins,\n       mapping = aes(x = body_mass_g, y = flipper_length_mm)) +\n    geom_point()\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\n\n\nWe use the data and mapping arguments in the ggplot() function to define the input data and the aesthetic mappings, respectively. When constructing this code, we explicitly write the names of arguments (e.g. data = ...). This is called using named arguments.\nCompare this to the following code, which generates the exact same scatterplot:\n\nggplot(penguins,\n       aes(x = body_mass_g, y = flipper_length_mm)) +\n    geom_point()\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\n\n\nWhy do you think this works? Hint: look at the ‘Usage’ section on the help page for ggplot()\nWhen we don’t provide the names of arguments, R uses their positions in the function call to identify which values to assign to which argument. This is called using positional arguments. You can find the order of arguments that R expects for a function by referring to the help documentation, or by using the args() function.\n\nargs(ggplot)\n\nfunction (data = NULL, mapping = aes(), ..., environment = parent.frame()) \nNULL\n\n\nNow that we’ve seen the order of the arguments the ggplot() function expects, let’s re-examine the second block of code we used to create the scatterplot.\n\nggplot(penguins,\n       aes(x = body_mass_g, y = flipper_length_mm)) +\n    geom_point()\n\nThe first argument the ggplot() function expects in the data argument. In this code, penguins is the first argument we provide. Since we didn’t specify an argument name, R automatically assigns it to the data argument. Similarly, the aesthetic mapping (aes(...)) is the second argument we provide. Again, we didn’t specify an argument name so R automatically assigns it to mapping, the next unused argument in list of arguments returned by the args(ggplot).\nBoth argument conventions offer advantages. When we use named arguments, we can provide them in any order.\n\nggplot(mapping = aes(x = body_mass_g, y = flipper_length_mm),\n       data = penguins) +\n    geom_point()\n\nPositional arguments save us some typing and make use more efficient programmers, particularly for functions that we re-use often in our code. For example, since the first argument for most dplyr functions is the input data, we tend define the data using a positional argument.\nWe can also use a mix of named and positional arguments in the same function call:\n\nggplot(aes(x = body_mass_g, y = flipper_length_mm),\n       data = penguins) +\n    geom_point()\n\nEven though the mapping aes() is the first positional argument R assigns it to the mapping argument. This is because we’ve explicitly defined the data as a named argument elsewhere in the function call. When R assigns positional arguments, it first assigns all of the named arguments, then assigns positional arguments to whatever is left. In the above example, when R goes to assign the aesthetics it skips the data argument, because we define data using a named argument, and assigns aes(...) to the next mapping, which is the next un-used argument after data.\n\n\nR version 4.3.1 (2023-06-16 ucrt)\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\nRunning under: Windows 10 x64 (build 19045)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\ntime zone: America/New_York\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] ggplot2_3.4.4        palmerpenguins_0.1.1\n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.4       cli_3.6.1         knitr_1.45        rlang_1.1.1      \n [5] xfun_0.41         generics_0.1.3    jsonlite_1.8.7    labeling_0.4.3   \n [9] glue_1.6.2        colorspace_2.1-0  htmltools_0.5.6.1 scales_1.2.1     \n[13] fansi_1.0.5       rmarkdown_2.25    grid_4.3.1        evaluate_0.23    \n[17] munsell_0.5.0     tibble_3.2.1      fastmap_1.1.1     yaml_2.3.7       \n[21] lifecycle_1.0.3   compiler_4.3.1    dplyr_1.1.3       htmlwidgets_1.6.2\n[25] pkgconfig_2.0.3   rstudioapi_0.15.0 farver_2.1.1      digest_0.6.33    \n[29] R6_2.5.1          tidyselect_1.2.0  utf8_1.2.4        pillar_1.9.0     \n[33] magrittr_2.0.3    withr_2.5.2       tools_4.3.1       gtable_0.3.4     \n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-02_Working-with-tabular-data.html",
    "href": "LESSONS/COMPLETED/Completed_Lesson-02_Working-with-tabular-data.html",
    "title": "Lesson 2: Working with tabular data",
    "section": "",
    "text": "For this lesson we’ll need four packages:\n\npalmerpenguins\nhere\nreadr\ndplyr\n\nFirst, we need to install the here package, using the install.packages() function.\n\ninstall.packages(\"here\")\n\nNote, the readr and dplyr packages are part of the tidyverse, so we don’t need to install them separately. Now we use the library() function to load all of these packages.\n\nlibrary(palmerpenguins)\nlibrary(here)\n\nhere() starts at C:/Users/nickopotamus/Projects/ITMAT_office_houRs\n\nlibrary(readr)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n\nThe output from this code indicates R successfully loaded these packages. The message we get from the here package tells us which directory on our computers it’s using as the “root” directory (more on what this means below). The other warning messages explains that dplyr includes several functions (e.g. filter() and lag()) that have the same names as functions from the stats and base packages. R’s default behavior for resolving these naming conflicts is to use the version of the function loaded most recently into memory. The warning lets us know that if we run any of these functions, R will use the version of these functions from the dplyr package and not the stats/base package.\nThe potential for naming conflicts like this is another reason why we only load the packages we need for the current analyses.\n\n\n\n\n\n\nRStudio’s Tab-Complete List Includes Package Names for Each Function\n\n\n\nWhen we start to type a function’s name, and RStudio’s tab-completion prompt opens up, the package for each function is listed in curly bracers to the right of the function’s name. As we’re writing code, we can use this to make sure we’re using the correct version of the function."
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-02_Working-with-tabular-data.html#base-r",
    "href": "LESSONS/COMPLETED/Completed_Lesson-02_Working-with-tabular-data.html#base-r",
    "title": "Lesson 2: Working with tabular data",
    "section": "2.1 Base R",
    "text": "2.1 Base R\nWe can read the data from this file using the base R function read.csv() and store the data in a variable named penguin_data_from_base_r.\n\npenguin_data_from_base_r &lt;- read.csv(file = here::here(\"DATA/penguins.csv\"))\n\nIn R, &lt;- is called the assignment operator. The assignment operator takes the output from the function to its right (read.csv()) and assigns it to the variable to its right (penguin_data_from_base_r). Put differently, we’re storing the contents of the ‘penguins.csv’ file in ‘penguin_data_from_base_r’.\n\n\n\n\n\n\nThe here package\n\n\n\nThe here() function is helping to point R to the specific location of the file. It allows us to define a file’s location relative to the project’s main directory (ITMAT_office_houRs, in this case). While the here() function is not required to read files, it can make our lives easier when we’re using RStudio’s ‘Projects’ to manage our work.\n\n\nWe can look at the contents of penguin_data_from_base_r by entering the variable name into the R console.\n\npenguin_data_from_base_r\n\n   species    island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n1   Adelie Torgersen           39.1          18.7               181        3750\n2   Adelie Torgersen           39.5          17.4               186        3800\n3   Adelie Torgersen           40.3          18.0               195        3250\n4   Adelie Torgersen             NA            NA                NA          NA\n5   Adelie Torgersen           36.7          19.3               193        3450\n6   Adelie Torgersen           39.3          20.6               190        3650\n7   Adelie Torgersen           38.9          17.8               181        3625\n8   Adelie Torgersen           39.2          19.6               195        4675\n9   Adelie Torgersen           34.1          18.1               193        3475\n10  Adelie Torgersen           42.0          20.2               190        4250\n11  Adelie Torgersen           37.8          17.1               186        3300\n12  Adelie Torgersen           37.8          17.3               180        3700\n13  Adelie Torgersen           41.1          17.6               182        3200\n14  Adelie Torgersen           38.6          21.2               191        3800\n15  Adelie Torgersen           34.6          21.1               198        4400\n16  Adelie Torgersen           36.6          17.8               185        3700\n17  Adelie Torgersen           38.7          19.0               195        3450\n18  Adelie Torgersen           42.5          20.7               197        4500\n      sex year\n1    male 2007\n2  female 2007\n3  female 2007\n4    &lt;NA&gt; 2007\n5  female 2007\n6    male 2007\n7  female 2007\n8    male 2007\n9    &lt;NA&gt; 2007\n10   &lt;NA&gt; 2007\n11   &lt;NA&gt; 2007\n12   &lt;NA&gt; 2007\n13 female 2007\n14   male 2007\n15   male 2007\n16 female 2007\n17 female 2007\n18   male 2007\n [ reached 'max' / getOption(\"max.print\") -- omitted 326 rows ]\n\n\nNotice, that “penguin_data_from_base_r” now appears in the Environment tab of the upper right pane of the RStudio window. We can use this tab to quickly check the data we’ve loaded into R.\nWhile the read.csv() function gets the job done, it doesn’t do a lot to format the data."
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-02_Working-with-tabular-data.html#the-readr-package",
    "href": "LESSONS/COMPLETED/Completed_Lesson-02_Working-with-tabular-data.html#the-readr-package",
    "title": "Lesson 2: Working with tabular data",
    "section": "2.2 The readr package",
    "text": "2.2 The readr package\n\n\n\n\n\nAs the name implies, the readr package contains functions designed to help us read tabular data from text files. These functions have a lot of useful features to mark and handle problems we’re likely to encounter in real-world data (we’ll see some examples of this in later lessons).\nTo read this csv file, we’re going to use the read_csv() function from the readr package. The command is almost identical to base R, except we have an underscore in read_csv(), instead of a period.\n\npenguin_data_from_readr &lt;- read_csv(file = here::here(\"DATA/penguins.csv\"))\n\nRows: 344 Columns: 8\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): species, island, sex\ndbl (5): bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g, year\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nThe readr function includes some additional output that tells us about guesses it’s making about data in the file. Specifically, it determined the species, island, and sex columns contain text (or “characters”), while the remaining columns contain numbers with decimal points (or “doubles”).\nCompare the the contents of the penguin_data_from_readr to the penguin_data_from_base_r data we loaded above:\n\npenguin_data_from_readr\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\nreadr functions read data from files and store them as tibbles, a special version of a data frame. We saw an example of a tibble when we worked with the penguins data frame, loaded by the palmerpenguins package."
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-02_Working-with-tabular-data.html#the-dplyr-package",
    "href": "LESSONS/COMPLETED/Completed_Lesson-02_Working-with-tabular-data.html#the-dplyr-package",
    "title": "Lesson 2: Working with tabular data",
    "section": "3.1 The dplyr Package",
    "text": "3.1 The dplyr Package\n\n\n\n\n\nThe dplyr package comes with many functions for manipulating and extracting information from tabular data. As we’ll see below, dplyr functions are named after verbs that describe what we’re doing to the input data, and the first argument of every function is the input data frame (or tibble).\nFor simplicity, we’ll return to using the penguins data frame for the remainder of this lesson. While we could use dplyr functions to work with the data we read from penguins.csv, the penguins data frame has some nicer formatting."
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-02_Working-with-tabular-data.html#filter",
    "href": "LESSONS/COMPLETED/Completed_Lesson-02_Working-with-tabular-data.html#filter",
    "title": "Lesson 2: Working with tabular data",
    "section": "3.2 Filter",
    "text": "3.2 Filter\nWe can use the filter() function to grab rows from our data that contain specific information. Here, we extract just those rows containing measurements from Gentoo penguins.\n\nfilter(penguins, species == \"Gentoo\")\n\n# A tibble: 124 × 8\n   species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Gentoo  Biscoe           46.1          13.2               211        4500\n 2 Gentoo  Biscoe           50            16.3               230        5700\n 3 Gentoo  Biscoe           48.7          14.1               210        4450\n 4 Gentoo  Biscoe           50            15.2               218        5700\n 5 Gentoo  Biscoe           47.6          14.5               215        5400\n 6 Gentoo  Biscoe           46.5          13.5               210        4550\n 7 Gentoo  Biscoe           45.4          14.6               211        4800\n 8 Gentoo  Biscoe           46.7          15.3               219        5200\n 9 Gentoo  Biscoe           43.3          13.4               209        4400\n10 Gentoo  Biscoe           46.8          15.4               215        5150\n# ℹ 114 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nRemember, the species information in our data frame is contained in the “species” column. This example code is telling R to search through every row in the penguin data, and return those rows that have “Gentoo” in the species column. From this example, we can see the general form for using the filter function: filter(dataset, comparison). We used “==” to indicate we want to find all rows in species that match the word “Gentoo”. This is an example of a relational operator.\n\n\n\n\n\n\nCompare Values With Relational Operators\n\n\n\nR supports several operators that let us compare values:\n\n== : Check if two values are exactly equal. Many programming languages use the double equals sign to indicate comparisons, because they’re already using the single equal sign for something else (e.g. assignment).\n&lt;, &gt; : Less-than, and greater-than comparisons.\n&lt;=, &gt;= : Less-than or equal, and greater-than or equal comparisons.\n!= : Check if two values are not equal.\n\nThese operators return a logical value: TRUE or FALSE.\n\n\"Gentoo\" == \"Gentoo\"\n\n[1] TRUE\n\n121 &lt; 43\n\n[1] FALSE\n\n\n\n\nWe can also combine multiple filtering conditions in the same command. In this example, we want to get the rows containing data from female Adelie penguins.\n\nfilter(penguins,\n       sex == \"female\",\n       species == \"Adelie\")\n\n# A tibble: 73 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.5          17.4               186        3800\n 2 Adelie  Torgersen           40.3          18                 195        3250\n 3 Adelie  Torgersen           36.7          19.3               193        3450\n 4 Adelie  Torgersen           38.9          17.8               181        3625\n 5 Adelie  Torgersen           41.1          17.6               182        3200\n 6 Adelie  Torgersen           36.6          17.8               185        3700\n 7 Adelie  Torgersen           38.7          19                 195        3450\n 8 Adelie  Torgersen           34.4          18.4               184        3325\n 9 Adelie  Biscoe              37.8          18.3               174        3400\n10 Adelie  Biscoe              35.9          19.2               189        3800\n# ℹ 63 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nAlternatively, we can combine multiple conditions with the & symbol (meaning “and”) and the | symbol (meaning “or”). We can re-write the previous filter command using the & symbol:\n\nfilter(penguins,\n       sex == \"female\" & species == \"Adelie\")\n\n# A tibble: 73 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.5          17.4               186        3800\n 2 Adelie  Torgersen           40.3          18                 195        3250\n 3 Adelie  Torgersen           36.7          19.3               193        3450\n 4 Adelie  Torgersen           38.9          17.8               181        3625\n 5 Adelie  Torgersen           41.1          17.6               182        3200\n 6 Adelie  Torgersen           36.6          17.8               185        3700\n 7 Adelie  Torgersen           38.7          19                 195        3450\n 8 Adelie  Torgersen           34.4          18.4               184        3325\n 9 Adelie  Biscoe              37.8          18.3               174        3400\n10 Adelie  Biscoe              35.9          19.2               189        3800\n# ℹ 63 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nWe can use the | symbol to retrieve data from female penguins that are either Adelie or Chinstrap:\n\nfilter(penguins,\n       sex == \"female\",\n       species == \"Adelie\" | species == \"Chinstrap\")\n\n# A tibble: 107 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.5          17.4               186        3800\n 2 Adelie  Torgersen           40.3          18                 195        3250\n 3 Adelie  Torgersen           36.7          19.3               193        3450\n 4 Adelie  Torgersen           38.9          17.8               181        3625\n 5 Adelie  Torgersen           41.1          17.6               182        3200\n 6 Adelie  Torgersen           36.6          17.8               185        3700\n 7 Adelie  Torgersen           38.7          19                 195        3450\n 8 Adelie  Torgersen           34.4          18.4               184        3325\n 9 Adelie  Biscoe              37.8          18.3               174        3400\n10 Adelie  Biscoe              35.9          19.2               189        3800\n# ℹ 97 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nLet’s use the filter function to create a new data frame that just contains rows from our penguin data from Gentoo penguins.\n\ngentoo_penguin_data &lt;- filter(penguins, species == \"Gentoo\")"
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-02_Working-with-tabular-data.html#select",
    "href": "LESSONS/COMPLETED/Completed_Lesson-02_Working-with-tabular-data.html#select",
    "title": "Lesson 2: Working with tabular data",
    "section": "3.3 Select",
    "text": "3.3 Select\nWith the filter() function, we can choose which rows we want to extract from our data. If we want to choose which columns to extract, we use the select() function. Here we extract the columns containing the species, flipper length, and body mass from each penguin in the dataset.\n\nselect(penguins, species, flipper_length_mm, body_mass_g)\n\n# A tibble: 344 × 3\n   species flipper_length_mm body_mass_g\n   &lt;fct&gt;               &lt;int&gt;       &lt;int&gt;\n 1 Adelie                181        3750\n 2 Adelie                186        3800\n 3 Adelie                195        3250\n 4 Adelie                 NA          NA\n 5 Adelie                193        3450\n 6 Adelie                190        3650\n 7 Adelie                181        3625\n 8 Adelie                195        4675\n 9 Adelie                193        3475\n10 Adelie                190        4250\n# ℹ 334 more rows\n\n\nFrom this example code, we can see the general form of the select() function: select(dataset, column_name1, column_name2, ...). The select() function is very useful for reducing our dataset to just the columns we need for a particular calculation or analysis. This is critical when we’re working with input data that have 100s of columns.\nAbove, we created a data frame that only contains data from Gentoo penguins. Now let’s use the select() function on that data frame to extract the columns containing the species, flipper length, and body mass measurements. We’ll save the selected data frame in a new variable.\n\ngentoo_body_and_flipper &lt;- select(gentoo_penguin_data,\n                                  species,\n                                  flipper_length_mm,\n                                  body_mass_g)"
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-02_Working-with-tabular-data.html#mutate",
    "href": "LESSONS/COMPLETED/Completed_Lesson-02_Working-with-tabular-data.html#mutate",
    "title": "Lesson 2: Working with tabular data",
    "section": "3.4 Mutate",
    "text": "3.4 Mutate\n\n\n\nArtwork by @allison_horst\n\n\nIf we want to add new columns to a data frame, We use the mutate() function. Here, we add a new column which contains the body mass of each penguins in kilograms (the “body_mass_g” column is in grams).\n\nmutate(penguins,\n       body_mass_kg = body_mass_g / 1000)\n\n# A tibble: 344 × 9\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 3 more variables: sex &lt;fct&gt;, year &lt;int&gt;, body_mass_kg &lt;dbl&gt;\n\n\nFrom this code, we can see the general form of the mutate() function: mutate(dataset, new_column_name = expression). In this example, used the “/” operator to indicate we want to divide penguin body mass in grams by 1000, to calculate the body mass in kilograms. This is an example of an arithmetic operator.\n\n\n\n\n\n\nArithmetic Operators\n\n\n\nR supports several operators that allow us to perform various mathematical operations:\n\n+ addition\n- subtraction\n* multiplication\n/ division\n^ exponentiation\n\nWhen we use these operators on the column of a data frame, they’re designed to work separately on each value in the column (called an “element wise” operation).\n\n\nNote that mutate() adds new columns to the right side of the data frame. If we want to add new columns in different locations, we can use the .before and .after arguments.\n\nmutate(penguins,\n       body_mass_kg = body_mass_g / 1000,\n       .after = body_mass_g)\n\n# A tibble: 344 × 9\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 3 more variables: body_mass_kg &lt;dbl&gt;, sex &lt;fct&gt;, year &lt;int&gt;\n\n\nWe can provide .after and .before with either a column name (like we did above), or a number referring to the position in the table we want to insert the new column. Here we insert the new column before the current second column:\n\nmutate(penguins,\n       body_mass_kg = body_mass_g / 1000,\n       .before = 2)\n\n# A tibble: 344 × 9\n   species body_mass_kg island    bill_length_mm bill_depth_mm flipper_length_mm\n   &lt;fct&gt;          &lt;dbl&gt; &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;\n 1 Adelie          3.75 Torgersen           39.1          18.7               181\n 2 Adelie          3.8  Torgersen           39.5          17.4               186\n 3 Adelie          3.25 Torgersen           40.3          18                 195\n 4 Adelie         NA    Torgersen           NA            NA                  NA\n 5 Adelie          3.45 Torgersen           36.7          19.3               193\n 6 Adelie          3.65 Torgersen           39.3          20.6               190\n 7 Adelie          3.62 Torgersen           38.9          17.8               181\n 8 Adelie          4.68 Torgersen           39.2          19.6               195\n 9 Adelie          3.48 Torgersen           34.1          18.1               193\n10 Adelie          4.25 Torgersen           42            20.2               190\n# ℹ 334 more rows\n# ℹ 3 more variables: body_mass_g &lt;int&gt;, sex &lt;fct&gt;, year &lt;int&gt;\n\n\nLet’s use the mutate() function to add a body mass (mg) column to the data frame of Gentoo data we’ve been working on so far. We’ll save this expanded data frame in a new variable.\n\ngentoo_body_mg_and_flipper &lt;- mutate(gentoo_body_and_flipper,\n                                     body_mass_mg = body_mass_g * 1000,\n                                     .after = body_mass_g)"
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-02_Working-with-tabular-data.html#pipes-in-r",
    "href": "LESSONS/COMPLETED/Completed_Lesson-02_Working-with-tabular-data.html#pipes-in-r",
    "title": "Lesson 2: Working with tabular data",
    "section": "3.5 Pipes in R",
    "text": "3.5 Pipes in R\nR has a functionality allowing us to take the output of one function and provide it as input to another. The general name for this type of operation is “piping”. The pipe operator in R is |&gt;. Here we use the filter() function, the R pipe (|&gt;), and the head() function to view the first six rows returned by the filter function.\n\nfilter(penguins, species == \"Gentoo\") |&gt; head()\n\n# A tibble: 6 × 8\n  species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Gentoo  Biscoe           46.1          13.2               211        4500\n2 Gentoo  Biscoe           50            16.3               230        5700\n3 Gentoo  Biscoe           48.7          14.1               210        4450\n4 Gentoo  Biscoe           50            15.2               218        5700\n5 Gentoo  Biscoe           47.6          14.5               215        5400\n6 Gentoo  Biscoe           46.5          13.5               210        4550\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nIn this R code, we use the filter() command to extract all of the rows from the data containing measurements from Gentoo penguins. We then use the |&gt; operator to send the output of the filter() function to the head() function. The head() function returns the first 6 rows from its input data frame.\n\n\n\n\n\n\nRStudio’s pipe shortcut\n\n\n\nWhen working in RStudio, we can use the shortcut Ctrl/Cmd + Shift + M to enter the pipe.\n\n\nOver the last three sections we used the filter(), select(), and mutate() functions to create this data frame:\n\nhead(gentoo_body_mg_and_flipper)\n\n# A tibble: 6 × 4\n  species flipper_length_mm body_mass_g body_mass_mg\n  &lt;fct&gt;               &lt;int&gt;       &lt;int&gt;        &lt;dbl&gt;\n1 Gentoo                211        4500      4500000\n2 Gentoo                230        5700      5700000\n3 Gentoo                210        4450      4450000\n4 Gentoo                218        5700      5700000\n5 Gentoo                215        5400      5400000\n6 Gentoo                210        4550      4550000\n\n\nWe saved each of the intermediates to their own variables (take a look in the Environment tab to see the list of variables). Alternatively, we can use the pipe to generate the same data frame without saving any of the intermediate results:\n\npenguins |&gt; \n    filter(species == \"Gentoo\") |&gt; \n    select(species, flipper_length_mm, body_mass_g) |&gt; \n    mutate(body_mass_mg = body_mass_g * 1000,\n           .before = body_mass_g) |&gt; \n    head()\n\n# A tibble: 6 × 4\n  species flipper_length_mm body_mass_mg body_mass_g\n  &lt;fct&gt;               &lt;int&gt;        &lt;dbl&gt;       &lt;int&gt;\n1 Gentoo                211      4500000        4500\n2 Gentoo                230      5700000        5700\n3 Gentoo                210      4450000        4450\n4 Gentoo                218      5700000        5700\n5 Gentoo                215      5400000        5400\n6 Gentoo                210      4550000        4550\n\n\nWith the pipe operator, we can combine many simple R functions to create complex pipelines, all while keeping our code readable.\nUnder the hood, the |&gt; operator is taking the output of the function on its left and feeding it into the first argument of the function on its right. All dplyr functions are fully compatible with the pipe operator (the first argument of every function is the input data frame).\n\n\n\n\n\n\nAnother Pipe Operator: %&gt;%\n\n\n\nThe |&gt; pipe operator is a relatively recent (May 2021) addition to base R. Before that, we needed to use the %&gt;% operator, also called the “magrittr pipe.” This operator is still around and used in a lot of existing R code, but it requires us to load the magrittr package. In these lessons, we’ll only use the native |&gt; pipe operator, so we don’t need to load any extra packages."
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-02_Working-with-tabular-data.html#arrange",
    "href": "LESSONS/COMPLETED/Completed_Lesson-02_Working-with-tabular-data.html#arrange",
    "title": "Lesson 2: Working with tabular data",
    "section": "3.6 Arrange",
    "text": "3.6 Arrange\nWe can use the arrange() function to sort the rows in our data according to the values in one or more columns. Here we sort the penguins by bill depth:\n\npenguins |&gt; \n    arrange(bill_length_mm)\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Dream               32.1          15.5               188        3050\n 2 Adelie  Dream               33.1          16.1               178        2900\n 3 Adelie  Torgersen           33.5          19                 190        3600\n 4 Adelie  Dream               34            17.1               185        3400\n 5 Adelie  Torgersen           34.1          18.1               193        3475\n 6 Adelie  Torgersen           34.4          18.4               184        3325\n 7 Adelie  Biscoe              34.5          18.1               187        2900\n 8 Adelie  Torgersen           34.6          21.1               198        4400\n 9 Adelie  Torgersen           34.6          17.2               189        3200\n10 Adelie  Biscoe              35            17.9               190        3450\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nBy default, arrange() sorts values from smallest to largest (ascending). We can use the desc() function inside arrange to sort values from largest to smallest (descending).\n\narrange(penguins, desc(bill_depth_mm))\n\n# A tibble: 344 × 8\n   species   island   bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;     &lt;fct&gt;             &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie    Torgers…           46            21.5               194        4200\n 2 Adelie    Torgers…           38.6          21.2               191        3800\n 3 Adelie    Dream              42.3          21.2               191        4150\n 4 Adelie    Torgers…           34.6          21.1               198        4400\n 5 Adelie    Dream              39.2          21.1               196        4150\n 6 Adelie    Biscoe             41.3          21.1               195        4400\n 7 Chinstrap Dream              54.2          20.8               201        4300\n 8 Adelie    Torgers…           42.5          20.7               197        4500\n 9 Adelie    Biscoe             39.6          20.7               191        3900\n10 Chinstrap Dream              52            20.7               210        4800\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nLastly, we can sort data based on multiple columns:\n\narrange(penguins, island, desc(bill_depth_mm))\n\n# A tibble: 344 × 8\n   species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Biscoe           41.3          21.1               195        4400\n 2 Adelie  Biscoe           39.6          20.7               191        3900\n 3 Adelie  Biscoe           45.6          20.3               191        4600\n 4 Adelie  Biscoe           41            20                 203        4725\n 5 Adelie  Biscoe           37.8          20                 190        4250\n 6 Adelie  Biscoe           38.2          20                 190        3900\n 7 Adelie  Biscoe           42            19.5               200        4050\n 8 Adelie  Biscoe           42.2          19.5               197        4275\n 9 Adelie  Biscoe           35.9          19.2               189        3800\n10 Adelie  Biscoe           37.6          19.1               194        3750\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;"
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-02_Working-with-tabular-data.html#distinct",
    "href": "LESSONS/COMPLETED/Completed_Lesson-02_Working-with-tabular-data.html#distinct",
    "title": "Lesson 2: Working with tabular data",
    "section": "3.7 Distinct",
    "text": "3.7 Distinct\nThe distinct() function returns all unique rows from the data frame. We can provide the names of the columns we want to search for unique combinations. Here we want to find all unique combinations of species and island.\n\ndistinct(penguins, island, species)\n\n# A tibble: 5 × 2\n  island    species  \n  &lt;fct&gt;     &lt;fct&gt;    \n1 Torgersen Adelie   \n2 Biscoe    Adelie   \n3 Dream     Adelie   \n4 Biscoe    Gentoo   \n5 Dream     Chinstrap\n\n\nIf we don’t specify any column names, the distinct() function will look for unique combinations across all columns.\n\ndistinct(penguins)\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;"
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-02_Working-with-tabular-data.html#grouping-and-summarizing-data",
    "href": "LESSONS/COMPLETED/Completed_Lesson-02_Working-with-tabular-data.html#grouping-and-summarizing-data",
    "title": "Lesson 2: Working with tabular data",
    "section": "3.8 Grouping and Summarizing Data",
    "text": "3.8 Grouping and Summarizing Data\nWe started transforming these data because we wanted to extract some summary stats about the body mass and flipper length of the three penguin species in our data. With the functions we’ve used so far, we can extract the data we need for a specific penguin species. Here, we use the summarize() function to calculate the mean mean body mass and flipper length across all Gentoo penguins in our data.\n\npenguins |&gt; \n    filter(species == \"Gentoo\") |&gt; \n    select(species, flipper_length_mm, body_mass_g) |&gt; \n    na.omit() |&gt; # Filter out any rows containing NA values in any columns\n    summarize(mean_body_mass_g = mean(body_mass_g),\n              mean_flipper_length_mm = mean(flipper_length_mm))\n\n# A tibble: 1 × 2\n  mean_body_mass_g mean_flipper_length_mm\n             &lt;dbl&gt;                  &lt;dbl&gt;\n1            5076.                   217.\n\n\nIn this example we use dplyr functions and the pipe operator to filter our data for Gentoo penguins, select our columns of interest (body_mass_g and flipper_length_mm), and the summarize() function (also from dplyr) to calculate the mean values across data in the body_mass_g and flipper_length_mm columns.\n\n\n\n\n\n\nMissing Data\n\n\n\nThe first time we ran the code above, we didn’t use the na.omit() function and our mean body mass and flipper length calculations returned ‘NA’ values. ‘NA’ is one of the ways R represents missing data, and it turns out one of the penguins in our dataset has ‘NA’ values for all of its measurements (you can find it by looking through the data with the View() function). Many function that perform mathematical operations (like mean), will return an ‘NA’ value if any of its inputs are ‘NA’. This is so we’re aware there are ‘NA’ values present in our data and can handle them accordingly. Once we realized there was a single ‘NA’ values in our data, we excluded it using the na.omit() function.\n\n\nFrom this code, we see the general form of the summarize() function: summarize(dataset, column_name = expression). This is quite similar to the mutate() function. However, while the mutate() function performs a calculation for each row in a data frame column, the summarize() function performs one calculation using all of the data in a column.\nUsing the summarize() function we can quickly calculate summary stats from the columns in a data frame. In order to get the same summary stats for the other penguin data, we’d need to repeat the same set of operations two more times (one for each species). Ideally, we want to be able to work on data from all three penguin species at the same time.\nWe can do this with the group_by() function.\n\npenguins |&gt; \n    select(species, body_mass_g, flipper_length_mm) |&gt; \n    group_by(species) |&gt; \n    # This time we're using arguments in the mean function to remove the NA values\n    summarize(mean_body_mass_g = mean(body_mass_g, na.rm = TRUE),\n              mean_flipper_length_mm = mean(flipper_length_mm, na.rm = TRUE))\n\n# A tibble: 3 × 3\n  species   mean_body_mass_g mean_flipper_length_mm\n  &lt;fct&gt;                &lt;dbl&gt;                  &lt;dbl&gt;\n1 Adelie               3701.                   190.\n2 Chinstrap            3733.                   196.\n3 Gentoo               5076.                   217.\n\n\nHere we use the group_by() function to group the data according to the species column, before using the summarize() function. This grouping causes the summarize() function to perform calculations across the data within each group (species, in this case), rather than across the entire data frame.\nThe means don’t give us the whole picture, so let’s calculate the standard deviations for each of these measurements, as well as the total number of penguins from each species.\n\npenguins |&gt; \n    select(species, body_mass_g, flipper_length_mm) |&gt; \n    group_by(species) |&gt; \n    na.omit() |&gt;\n    summarize(mean_body_mass_g = mean(body_mass_g),\n              sd_body_mass_g = sd(body_mass_g),\n              mean_flipper_length_mm = mean(flipper_length_mm),\n              sd_mean_flipper_length_mm = sd(flipper_length_mm),\n              Total_animals = n())\n\nIt looks like the raw numbers agree with what we saw in the figure we generated in the previous lesson. Namely, the Gentoo penguins tend to have more mass and longer flippers than the other two species. And while the Chinstrap penguins have higher mean body mass and flipper length than the Adélie penguins, the standard deviations in these measurements are large enough that there probably isn’t a significant difference in size between the two. In the coming lessons, we’ll apply some statistical tests to these data to test our hypotheses.\n\n\n\n\n\n\nNot all operations are equivalent\n\n\n\nSo far, we’ve seen two ways of keeping ‘NA’ values from affecting our calculations: 1. The na.omit() function removes all rows from a data frame that contain ‘NA’ values in any column. 2. The mean() and sd() have an na.rm argument that excludes all ‘NA’ values from the mean / standard deviation calculations when we set it to TRUE (na.rm = TRUE).\nWe used the na.omit() function to exclude the ‘NA’ values before we used the summarize() function to calculated all of our summary statistics above. However, if we skip the na.omit() function and instead use the “na.rm” argument for mean() and sd() to exclude the ‘NA’ values, we get a slightly different result.\n\npenguins |&gt; \n    select(species, body_mass_g, flipper_length_mm) |&gt; \n    group_by(species) |&gt; \n    # na.omit() |&gt;\n    summarize(mean_body_mass_g = mean(body_mass_g, na.rm = TRUE),\n              sd_body_mass_g = sd(body_mass_g, na.rm = TRUE),\n              mean_flipper_length_mm = mean(flipper_length_mm, na.rm = TRUE),\n              sd_mean_flipper_length_mm = sd(flipper_length_mm, na.rm = TRUE),\n              Total_animals = n())\n\n# A tibble: 3 × 6\n  species   mean_body_mass_g sd_body_mass_g mean_flipper_length_mm\n  &lt;fct&gt;                &lt;dbl&gt;          &lt;dbl&gt;                  &lt;dbl&gt;\n1 Adelie               3701.           459.                   190.\n2 Chinstrap            3733.           384.                   196.\n3 Gentoo               5076.           504.                   217.\n# ℹ 2 more variables: sd_mean_flipper_length_mm &lt;dbl&gt;, Total_animals &lt;int&gt;\n\n\nCompare these results to the previous code using na.omit(), paying close attention to the “Total_animals” column. If there are too many columns in the results to compare them easily, you could always use the select() function to grab just the “species” and “Total_animals” columns.\nWhen we used the na.rm argument approach, we ended with with one extra penguin in the “Total_animals” column for the Adélie and Gentoo penguins. This is because the n() function counts rows, regardless of their contents (you can confirm there’s no na.rm argument for n() using the R docs). While there are many different ways to accomplish the same task, they are not all equivalent in all cases. If we weren’t also using the n() function to count the total number of penguins in each species, both of our methods for removing the ‘NA’ values would have produced the same result.\n\n\nEven though this is a toy example, we’ve created a flexible analysis pipeline by combining these dplyr functions, The code we’ve written will still work if we collect new data from different penguin species, add additional biological measurements beyond body mass and flipper length, or remove some of the rows from the original input data."
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-00_R-and-Rstudio-setup.html",
    "href": "LESSONS/COMPLETED/Completed_Lesson-00_R-and-Rstudio-setup.html",
    "title": "Lesson 0: R & Rstudio Setup",
    "section": "",
    "text": "The first thing we need to do is install a program that will allow our computers to read and execute R code. This is what we mean by “installing R.”\nFor general information on the current state of R you can visit the R Project homepage. To download the latest version of R, navigate to this page, click the link(s) specific to your operating system, and follow the instructions.\nThis will be a two step procedure for Windows and macOS users: first you’ll download the R installer from the above link, then you’ll run the installer on your computer. Windows users should select the ‘base’ version of R when given the choice between downloading ‘base’, ‘contrib’, and ‘old contrib’. After you’ve downloaded the installer, double-click it to run. You should be fine selecting the default choice when given the option to customize your installation. The customization options won’t affect how we interact with R, since we’ll be doing our work through RStudio.\nFor many Linux users, you’ll download and install R in one step using the package management software specific to your Linux distribution. The R page contains more detailed instructions for several common Linux distributions.\nAfter you complete the installation process, you should now have the ability to launch R as a stand-alone application on your computer. Note, the R application is separate from the R installer program you downloaded above.\n\n\n\nFor these lessons, we’ll be using the RStudio program to write our code and interact with R. While you only need to install R to write and run R code on your computer, RStudio has several nice features that will make working with R a much more pleasant experience.\nTo download the latest version of the RStudio desktop app installer, go to this page and select the option specific to your operating system. Run the installer after the download is complete. At this point, you should be able to launch the Rstudio app on your computer."
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-00_R-and-Rstudio-setup.html#download-install-r",
    "href": "LESSONS/COMPLETED/Completed_Lesson-00_R-and-Rstudio-setup.html#download-install-r",
    "title": "Lesson 0: R & Rstudio Setup",
    "section": "",
    "text": "The first thing we need to do is install a program that will allow our computers to read and execute R code. This is what we mean by “installing R.”\nFor general information on the current state of R you can visit the R Project homepage. To download the latest version of R, navigate to this page, click the link(s) specific to your operating system, and follow the instructions.\nThis will be a two step procedure for Windows and macOS users: first you’ll download the R installer from the above link, then you’ll run the installer on your computer. Windows users should select the ‘base’ version of R when given the choice between downloading ‘base’, ‘contrib’, and ‘old contrib’. After you’ve downloaded the installer, double-click it to run. You should be fine selecting the default choice when given the option to customize your installation. The customization options won’t affect how we interact with R, since we’ll be doing our work through RStudio.\nFor many Linux users, you’ll download and install R in one step using the package management software specific to your Linux distribution. The R page contains more detailed instructions for several common Linux distributions.\nAfter you complete the installation process, you should now have the ability to launch R as a stand-alone application on your computer. Note, the R application is separate from the R installer program you downloaded above."
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-00_R-and-Rstudio-setup.html#download-install-rstudio",
    "href": "LESSONS/COMPLETED/Completed_Lesson-00_R-and-Rstudio-setup.html#download-install-rstudio",
    "title": "Lesson 0: R & Rstudio Setup",
    "section": "",
    "text": "For these lessons, we’ll be using the RStudio program to write our code and interact with R. While you only need to install R to write and run R code on your computer, RStudio has several nice features that will make working with R a much more pleasant experience.\nTo download the latest version of the RStudio desktop app installer, go to this page and select the option specific to your operating system. Run the installer after the download is complete. At this point, you should be able to launch the Rstudio app on your computer."
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-00_R-and-Rstudio-setup.html#posit-cloud",
    "href": "LESSONS/COMPLETED/Completed_Lesson-00_R-and-Rstudio-setup.html#posit-cloud",
    "title": "Lesson 0: R & Rstudio Setup",
    "section": "2.1 Posit Cloud",
    "text": "2.1 Posit Cloud\nPosit, the company behind RStudio, provides a cloud-based infrastructure you can use to run RStudio through your web browser. This service is called ‘Posit Cloud’ and is accessible here. You need to create an account to access Posit Cloud and select a subscription tier. While the paid tiers offer more powerful compute resources, more storage, and more compute time, the free tier should be enough to run the R code in these lessons.\nWhen you launch Posit Cloud through your web browser, you have access to a fully featured instance of the RStudio app that is running on the cloud. This means that you can access and run RStudio anywhere you can open a web browser. It also means you’ll need to upload any data files you want to work on to the cloud servers, and download any results you want to store on your local computer. These upload/download procedures are pretty simple.\nLastly, the RStudio workspaces on Posit Cloud are persistent. This means that if you make changes to the R environment (e.g. by installing an R package) or upload files to Posit Cloud on one computer, the service saves these changes so you’ll have access to the same R environment and files when you login to Posit Cloud from another computer."
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-00_R-and-Rstudio-setup.html#webr",
    "href": "LESSONS/COMPLETED/Completed_Lesson-00_R-and-Rstudio-setup.html#webr",
    "title": "Lesson 0: R & Rstudio Setup",
    "section": "2.2 WebR",
    "text": "2.2 WebR\nWebAssembly is a recent effort to develop tools for running complex programs in a web browser. WebR is a version of R that’s designed to use WebAssembly to run R code. You can find information on WebR on this page. The authors of WebR have created a bare-bones WebR editor that mimics RStudio’s layout and lets you write and run R code in your browser (https://webr.r-wasm.org/latest/).\nWhile this WebR editor may seem similar to Posit Cloud, in that you’re accessing an R programming environment through your web browser, the big difference lies in where the R code is actually running. In Posit Cloud, all of the computations are happening on an RStudio server located somewhere else (probably an AWS warehouse). The Posit Cloud website acts as a portal that lets you communicate with this server, as if you’re running RStudio on your computer. WebR actually is running on your computer, inside your web browser. This means all of the computations are happening on your local computer and not on a cloud server.\nThis also means that the WebR environment is not persistent. With Posit Cloud, any changes you make to the R environment are saved to the cloud server, so you see these changes the next time you open Posit Cloud. Since the R environment for WebR is running inside your web browser, it ends when you close your web browser (or the tab that’s running WebR). This means you’ll need to re-install the R packages you want to use every time you load WebR.\nWhile WebR does provide an alternative to running RStudio on your computer or through Posit Cloud, it should be your last resort for running the R code in these lessons. WebR is relatively new and still under active development, which means things could break/change without much warning. Also, while the WebR editor visually resembles RStudio, it’s really a demo of what WebR can do and lacks RStudio’s helpful features. All that being said, it’s still worth knowing about WebR. It’s just plain cool and opens up a lot of possibilities for how we can share data analyses and visualizations with each other."
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-00_R-and-Rstudio-setup.html#base-r",
    "href": "LESSONS/COMPLETED/Completed_Lesson-00_R-and-Rstudio-setup.html#base-r",
    "title": "Lesson 0: R & Rstudio Setup",
    "section": "3.1 Base R",
    "text": "3.1 Base R\nThe functions and code included with every R installation are part of R’s base packages, also know as base R. The base packages include quite a bit of functionality on their own, providing us with functions for reading/writing files, mathematical calculations, graphing/plotting, as well as the framework upon which all other packages are built.\nWhile base R has its advantages, it can be a bit esoteric, particularly when you’re first starting out. We want to use packages to make our lives easier and our code more readable.\nThe R Foundation maintains a central repository and archive of R packages, known as CRAN (Comprehensive R Archive Network). Below, we’ll the install.packages() function to download and install some useful R packages from CRAN."
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-00_R-and-Rstudio-setup.html#the-tidyverse",
    "href": "LESSONS/COMPLETED/Completed_Lesson-00_R-and-Rstudio-setup.html#the-tidyverse",
    "title": "Lesson 0: R & Rstudio Setup",
    "section": "3.2 The tidyverse",
    "text": "3.2 The tidyverse\nThe tidyverse is a family of packages that will make it easier for us to read data from files, plot graphs, and generally wrangle data into useful formats. The bulk of these lessons (at least the early ones) are built around using various tidyverse packages to work with data.\nSince the tidyverse is not included with base R, we need to install it before we can use it. Run the following code to download and install the tidyverse packages:\n\ninstall.packages(\"tidyverse\")\n\nEven though we’ve downloaded and installed the tidyverse packages, we still can’t use any of their functions. Whenever we start a new R/RStudio session, it only loads the base R packages. This means R always starts quickly, no matter how many packages we’ve installed. It also means we have complete control over which packages are loaded into memory at any given time. Generally, we only want to load packages we know we’re going to use in the current R session. This keeps R’s memory footprint as small as possible, leaving more room for our data.\nWe load installed packages with the library() function. Note, when we load packages we don’t need to enclose the package names in quotation marks, like we did when running the install.packages() function.\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors"
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-00_R-and-Rstudio-setup.html#palmer-penguins",
    "href": "LESSONS/COMPLETED/Completed_Lesson-00_R-and-Rstudio-setup.html#palmer-penguins",
    "title": "Lesson 0: R & Rstudio Setup",
    "section": "3.3 Palmer Penguins",
    "text": "3.3 Palmer Penguins\n\n\n\nArtwork by @allison_horst\n\n\nNow that we’ve installed some tools to help us visualize and wrangle some data, we need a dataset to work with. For these lessons, we’ll start with the Palmer Penguins dataset.\nThe Palmer Penguins dataset contains anatomical and physiological measurements collected from three penguin species living on several islands near the Palmer Research Station in Antarctica. These data were collected by Dr. Kristin B. Gorman and the Palmer Station Long Term Ecological Research (LTER) program. This work was originally published in:\n\nGorman KB, Williams TD, Fraser WR (2014). Ecological sexual dimorphism and environmental variability within a community of Antarctic penguins (genus Pygoscelis). PLoS ONE 9(3):e90081.\n\nDr. Allison Horst, Dr. Alison Hill, and Dr. Kristen Gorman wrapped these data into the palmerpenguins R package.\n\n\n\nArtwork by @allison_horst\n\n\nHere, we’ll use the install.packages() function to install the \"palmerpenguins\" package. Construct this command and run it:\n\ninstall.packages(\"palmerpenguins\")\n\nNow that we’ve downloaded and installed the palmerpenguins package, use the library() function to load it.\n\nlibrary(palmerpenguins)\n\nNow that we’ve installed R, RStudio, and the tidyverse and palmerpenguins R packages, our computers are ready for the introductory R lessons."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Overview",
    "section": "",
    "text": "This is the companion website for the ITMAT office houRs. It’s under active development (as are my web programming skills) and will change a lot, so thank you in advance for your patience.\nYou can access the github repository for this website here.\n\n\n\n Back to top"
  },
  {
    "objectID": "lessons.html",
    "href": "lessons.html",
    "title": "Lessons",
    "section": "",
    "text": "Note\n\n\n\nTo download a file from the list below, right-click on the link and select the “Save Link As…” option (on Firefox). The specific text for this option might be a little different, depending on your web browser.\n\n\n\n\nLesson 0: R and RStudio setup\n\nView completed lesson\nDownloads:\n\nQuarto doc (save to LESSONS/ subdirectory)\n\n\nLesson 1: Visualizing data with ggplot2\n\nView completed lesson\nDownloads:\n\nQuarto doc (save to LESSONS/ subdirectory)\nGraph image (save to IMAGES/ subdirectory)\n\n\nLesson 2: Working with tabular data\n\nView completed lesson\nDownloads:\n\nQuarto doc (save to LESSONS/ subdirectory)\nData file (save to DATA/ subdirectory)\n\n\nLesson 3: Exploring geom_ functions and customizing ggplots\n\nView completed lesson\nDownloads:\n\nQuarto doc (save to LESSONS/ subdirectory)\n\n\n\n\nNotes & Nibbles\nDetours that arise from discussions and questions that aren’t long enough to warrant their own, full lessons.\n\nUsing named and positional arguments with functions\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-01_Visualizing-data-with-ggplot2.html",
    "href": "LESSONS/COMPLETED/Completed_Lesson-01_Visualizing-data-with-ggplot2.html",
    "title": "Lesson 1: Visualizing data with ggplot2",
    "section": "",
    "text": "When we start R, we only have access to the base R packages. In order to use any additional packages, we need to load them into memory with the library() function.\nFor this lesson we’ll need two packages: ggplot2 and palmerpenguins. Run the following code chunk to load these two packages. Note, the second library command is empty. Modify the command so it loads the palmerpenguins package.\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\n\nIt’s good practice to start R code, stored in R scripts or quarto/Rmarkdown documents, by loading the packages we’ll be using in the body of the code. It gives readers, including future versions of ourselves, a consistent place to check all of the packages required to run our code."
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-01_Visualizing-data-with-ggplot2.html#look-at-the-palmer-penguins-data-table",
    "href": "LESSONS/COMPLETED/Completed_Lesson-01_Visualizing-data-with-ggplot2.html#look-at-the-palmer-penguins-data-table",
    "title": "Lesson 1: Visualizing data with ggplot2",
    "section": "4.1 Look at the Palmer Penguins data table",
    "text": "4.1 Look at the Palmer Penguins data table\nAfter loading the palmerpenguins package, we now have access to table of penguin data. We can view the first 10 lines of this table directly in the R console:\n\npenguins\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nEach row in this table contains data from a single penguin measurement during the study period. Looking at the columns, we see all of the different information the researchers recorded about each penguin. We can also see that there are observations with missing information, represented by NA values. In R terminology, this is called a data frame. It is a natural way of representing rectangular, spreadsheet-style data. The penguin data are technically stored as a tibble, which is a special type of data frame used by the tidyverse.\nThe palmerpenguins package also contains documentation for the penguin data frame. Look up “penguins” using the Help pane, or one of the other help functions. The documentation describes the contents of each column in the data frame.\nIn addition to viewing the data frame in the R console, we can use the View() function to quickly examine its contents in a scrollable, spreadsheet-style window.\n\nView(penguins)\n\nInside the view window, we can search the data frame for specific values, or re-order it by values in each of the columns. While the View() function is useful for smaller datasets, it is not generally suitable for data frames with more than a few thousand rows.\n\n\n\n\n\n\nThe “V” in the View() function is capitalized\n\n\n\nIf we try to use the View() function with a lower case “v”, we’ll generally get an error:\n\nview(penguins)\n\nError in view(penguins): could not find function \"view\"\n\n\n\n\nLastly, we can use the summary() function to get summary statistics about the data in each column of our data frame.\n\nsummary(penguins)\n\n      species          island    bill_length_mm  bill_depth_mm  \n Adelie   :152   Biscoe   :168   Min.   :32.10   Min.   :13.10  \n Chinstrap: 68   Dream    :124   1st Qu.:39.23   1st Qu.:15.60  \n Gentoo   :124   Torgersen: 52   Median :44.45   Median :17.30  \n                                 Mean   :43.92   Mean   :17.15  \n                                 3rd Qu.:48.50   3rd Qu.:18.70  \n                                 Max.   :59.60   Max.   :21.50  \n                                 NA's   :2       NA's   :2      \n flipper_length_mm  body_mass_g       sex           year     \n Min.   :172.0     Min.   :2700   female:165   Min.   :2007  \n 1st Qu.:190.0     1st Qu.:3550   male  :168   1st Qu.:2007  \n Median :197.0     Median :4050   NA's  : 11   Median :2008  \n Mean   :200.9     Mean   :4202                Mean   :2008  \n 3rd Qu.:213.0     3rd Qu.:4750                3rd Qu.:2009  \n Max.   :231.0     Max.   :6300                Max.   :2009  \n NA's   :2         NA's   :2                                 \n\n\nThese functions help us building intuition about new datasets and spot potential problems for downstream analyses."
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-01_Visualizing-data-with-ggplot2.html#visualize-w-ggplot2",
    "href": "LESSONS/COMPLETED/Completed_Lesson-01_Visualizing-data-with-ggplot2.html#visualize-w-ggplot2",
    "title": "Lesson 1: Visualizing data with ggplot2",
    "section": "4.2 Visualize the penguin data with ggplot2",
    "text": "4.2 Visualize the penguin data with ggplot2\nThe penguins data frame contains measurements of each penguin’s body mass and flipper length. Here we will use the ggplot2 package to visualize these data and examine the relationship between these two anatomical measurements.\nBelow we’ll review the code we need to create this graph: \n\n4.2.1 How to create a basic scatterplot\nWe start with the ggplot() function, which creates our ggplot and specifies the data we want to use. Think of this like setting up a blank canvas before we start painting. Note, we’re giving the ggplot() function access to the penguin data frame with the data argument.\n\nggplot(data = penguins)\n\n\n\n\nNext, we use the mapping argument to tell the ggplot() function how we want it to use the penguin data. In ggplot2, we always use the aes() function to define how to map the variables (columns) in our data to the visual properties (aesthetics) of the shapes we want to paint. In this example we want to plot body mass with the x-axis and flipper length with the y-axis.\n\nggplot(data = penguins,\n       mapping = aes(x = body_mass_g, y = flipper_length_mm))\n\n\n\n\nNote how mapping the x/y aesthetics has affected the graph. The axes are now labeled and the ggplot() function has automatically set their ranges based on the range of body masses and flipper lengths in the penguin data frame.\nNow that we’ve prepared our canvas, we can start adding layers of paint. We paint shapes in ggplot2 using geom functions. Since we want to create a scatterplot, we’ll use the geom_point() function to add a layer of points to our plot. There is a whole family of different geom_ functions that we can use to plot different types of graphs (e.g. scatter plots, line graphs, bar graphs).\n\nggplot(data = penguins,\n       mapping = aes(x = body_mass_g, y = flipper_length_mm)) +\n    geom_point()\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\nNote that we combine the geom_point() function with the ggplot() function using the + sign. We can treat this like we’re “adding” a layer of points on top of the canvas we created with ggplot().\nAlso, take note of the warning we get from the ggplot2 code. Recall that we saw some columns with NA values when we were looking at the contents of the penguins data frame. The warning is telling us that two of the entries in the penguins data frame have NA values in either the body_mass_g or flipper_length_mm columns. The geom_point() function has no way of placing a point with a missing x- or y-coordinate, so ggplot2 automatically excludes rows with missing values before plotting. This filter only applies to columns (variables) in our data frame that we’re mapping to aesthetics. ggplot2 will still use rows in the penguins data frame that have NA values in the bill_length_mm and sex columns, since we’re not currently using those to plot anything.\nSo the general procedure we follow for plotting data with ggplot2 is to prepare our canvas with the ggplot() function, use the aes() function to tell ggplot2 how we want to use our data to paint the canvas, and apply paint to our canvas with a geom_ function (geom_point in the example above).\n\n\n4.2.2 Decorating our plots with more data\nNow that we have a basic scatterplot in hand, we can try to gain deeper insights into our data by incorporating more information into our plot. Our current scatterplot shows a positive relationship between flipper length and body mass. We know the penguin data frame contains measurements from three different penguin species. Let’s map species to the color aesthetic to see how this trend looks across all three species.\n\nggplot(data = penguins,\n       mapping = aes(x = body_mass_g, y = flipper_length_mm,\n                     color = species)) +\n    geom_point()\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\nNot only did ggplot2 automatically assign a different color to each penguin species, it also added a legend to the graph. That means this same block of code can work for a penguin data frame that contains data from one, two, or ten species of penguin.\nTo get a clearer picture of the trend between flipper length and body mass, we’re no going to add a regression line to the plot. We’ll do this with the geom_smooth() function. We’ll use the method = \"lm\" argument to specify we want to plot the line we get from fitting our data with a linear model.\n\nggplot(data = penguins,\n       mapping = aes(x = body_mass_g, y = flipper_length_mm,\n                     color = species)) +\n    geom_point() +\n    geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 2 rows containing non-finite values (`stat_smooth()`).\n\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\nIt looks like geom_smooth() fit separate linear models for each penguin species and plotted the lines using the same colors as the points. While this is a useful feature (we’ll make use of this below), we want to fit all of the data with a single linear model. When we define aesthetic mappings in the ggplot() function, they apply to all geom_ functions in that plot. By mapping species to color, we told geom_smooth() we want it to color the smoothed line by species, which means it needs to fit a separate line for each species. To solve this problem we can specify an aesthetic mapping within a specific geom_ function. Let’s try moving the species to color mapping to geom_point() and geom_smooth(). Which option still colors the points by species, but fits all of the data with a single linear model?\n\nggplot(data = penguins,\n       mapping = aes(x = body_mass_g, y = flipper_length_mm)) +\n    geom_point(mapping = aes(color = species)) +\n    geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 2 rows containing non-finite values (`stat_smooth()`).\n\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\nNow that we’ve sorted out the trend line, let’s return to how we’re plotting the points. The colors improve the readability of this graph, but could pose a problem if this figure is rendered in black and white, or if a reader has certain types of colorblindness. One solution is to map the points from different penguin species to different shapes. Try adding an aesthetic mapping of shape to species.\n\nggplot(data = penguins,\n       mapping = aes(x = body_mass_g, y = flipper_length_mm)) +\n    geom_point(mapping = aes(color = species, shape = species)) +\n    geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 2 rows containing non-finite values (`stat_smooth()`).\n\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\nNote that the legend automatically updates to reflect the new shape mapping.\nThe are many more aesthetics beyond shape and color. The documentation for geom_ functions contains a special section listing the aesthetic mappings supported by that geom. Look up the help page for “geom_point” and find the list of supported aesthetics.\nWe’re almost done recreating the figure we saw at the beginning of this section. The axis labels our version of the figure are not as clean, and we’re still missing the plot title and subtitle. Collectively, these attributes are known as the graph’s “labels”, and we can modify them using the labs() function.\n\nggplot(data = penguins,\n       mapping = aes(x = body_mass_g, y = flipper_length_mm)) +\n    geom_point(mapping = aes(color = species, shape = species)) +\n    geom_smooth(method = \"lm\") +\n    labs(title = \"Relationship between flipper length and body mass\",\n         subtitle = \"Across three species of penguins studied at the Palmer Research Station\",\n         x = \"Body mass (g)\",\n         y = \"Flipper length (mm)\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 2 rows containing non-finite values (`stat_smooth()`).\n\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\nLastly, we’ll change the color scheme to a different palette from the default. The ggplot2 package includes a few additional color palettes we can apply to our plot using scale_color_ functions. For now, we’ll select a palette from the ColorBrewer collection that is good for representing qualitative data and is more colorblind safe than the default palette.\n\nggplot(data = penguins,\n       mapping = aes(x = body_mass_g, y = flipper_length_mm)) +\n    geom_point(mapping = aes(color = species, shape = species)) +\n    geom_smooth(method = \"lm\") +\n    labs(title = \"Relationship between flipper length and body mass\",\n         subtitle = \"Across three species of penguins studied at the Palmer Research Station\",\n         x = \"Body mass (g)\",\n         y = \"Flipper length (mm)\") +\n    scale_color_brewer(palette = \"Dark2\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 2 rows containing non-finite values (`stat_smooth()`).\n\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\nFor now, we’re not going to worry about the specifics of the ColorBrewer collection of palettes (though feel free to examine the documentation for the scale_color_brewer() function). But we can see that we can further adjust how ggplot2 displays our data using the scale_ family of functions.\nWith that last tweak, we’ve successfully recreated the figure we saw above.\n\n\n4.2.3 Creating our own scatterplot\n\n\n\nArtwork by @allison_horst\n\n\nNow we’re going to put everything we just learned into practice. Using the penguins data and the ggplot2 functions, we’re going to create a scatterplot of bill depth vs bill length. We can view the contents of penguins data frame directly, or consult the documentation to find the names of the columns that contain this information. Again, we’ll add a regression line that we fit using all of the data.\n\nggplot(data = penguins,\n       mapping = aes(x = bill_depth_mm, y = bill_length_mm)) +\n    geom_point() +\n    geom_smooth(method = 'lm') +\n    labs(title = \"Bill length vs bill depth in three penguin species\",\n         x = \"Bill depth (mm)\",\n         y = \"Bill length (mm)\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 2 rows containing non-finite values (`stat_smooth()`).\n\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\nLooking at the graph we created, what does it suggest about a relationship between bill depth and bill length? How might species affect this? How does the graph change if we fit separate regression lines within each species?\n\nggplot(data = penguins,\n       mapping = aes(x = bill_depth_mm, y = bill_length_mm, color = species)) +\n    geom_point(mapping = aes(shape = species)) +\n    geom_smooth(method = 'lm') +\n    labs(title = \"Bill length vs bill depth in three penguin species\",\n         x = \"Bill depth (mm)\",\n         y = \"Bill length (mm)\") +\n    scale_color_brewer(palette = \"Dark2\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 2 rows containing non-finite values (`stat_smooth()`).\n\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\nThe difference between these two graphs is an example of Simpson’s paradox. Briefly, this is a phenomenon where a trend between two variables at the population level disappears, emerges, or reverses when we divide the population into groups. We were able to observe these changes by experimenting with the way we visualized the penguin data.\nWe’re only just scratching the surface of what we can do with ggplot2, but we’ve used it to rapidly visualize the penguin data and generate some interesting observations. In the next lesson, we will explore some of these observations further by working directly with the data to calculate summary statistics."
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-03_Exploring-geom-functions-and-customizing-ggplots.html",
    "href": "LESSONS/COMPLETED/Completed_Lesson-03_Exploring-geom-functions-and-customizing-ggplots.html",
    "title": "Lesson 3: Exploring geom_ functions and customizing ggplots",
    "section": "",
    "text": "For this lesson we’ll need four packages:\n\nmedicaldata (new package)\npalmerpenguins\nggplot2\ndplyr\n\nFirst, we need to install the medicaldata package, using the install.packages() function.\n\ninstall.packages(\"medicaldata\")\n\nNow we use the library() function to load all of these packages.\n\nlibrary(medicaldata)\n\nWarning: package 'medicaldata' was built under R version 4.3.2\n\nlibrary(palmerpenguins)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union"
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-03_Exploring-geom-functions-and-customizing-ggplots.html#refresher",
    "href": "LESSONS/COMPLETED/Completed_Lesson-03_Exploring-geom-functions-and-customizing-ggplots.html#refresher",
    "title": "Lesson 3: Exploring geom_ functions and customizing ggplots",
    "section": "3.1 Refresher",
    "text": "3.1 Refresher\nIn the first lesson, we used ggplot2 to generate a scatterplot from the penguin dataset. With this code block, we tell ggplot2 to use values from the ‘bill_length_mm’ column as x-axis coordinates, and values from the ‘flipper_length_mm’ column as y-axis coordinates. Remember, the aes() or “aesthetic” function tells ggplot2 how to map the columns in our data to visual components of the graph.\n\nggplot(data = penguins,\n       mapping = aes(x = bill_length_mm,\n                     y = flipper_length_mm)) +\n    geom_point()\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\nWe can streamline this code by using the R pipe (|&gt;) and by specifying data and mapping as positional arguments. Refer to the ggplot() documentation for the order of its arguments.\n\npenguins |&gt; \n    ggplot(aes(x = bill_length_mm,\n               y = flipper_length_mm)) +\n    geom_point()\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\nNote, when we’re constructing figures with ggplot2, we connect the ggplot2 functions using the ‘+’ sign, instead of the R pipe. This is because ggplot2 was written before there were any pipes in R. If we accidentally use an R pipe instead of a ‘+’ sign, we’ll get an error\n\npenguins |&gt; \n    ggplot(aes(x = bill_length_mm,\n               y = flipper_length_mm)) |&gt; \n    geom_point()\n\nError in `geom_point()`:\n! `mapping` must be created by `aes()`\nℹ Did you use `%&gt;%` or `|&gt;` instead of `+`?"
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-03_Exploring-geom-functions-and-customizing-ggplots.html#aesthetic-mapping",
    "href": "LESSONS/COMPLETED/Completed_Lesson-03_Exploring-geom-functions-and-customizing-ggplots.html#aesthetic-mapping",
    "title": "Lesson 3: Exploring geom_ functions and customizing ggplots",
    "section": "3.2 Aesthetic Mapping",
    "text": "3.2 Aesthetic Mapping\nLet’s modify the code to map the ‘species’ column to the ‘color’ aesthetic.\n\npenguins |&gt; \n    ggplot(aes(x = bill_length_mm,\n               y = flipper_length_mm,\n               color = species)) +\n    geom_point()\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\nWhat happens if we map the ‘body_mass_g’ column to color instead?\n\npenguins |&gt; \n    ggplot(aes(x = bill_length_mm,\n               y = flipper_length_mm,\n               color = body_mass_g)) +\n    geom_point()\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\nNotice that we see a color gradient. When we used species to color the points, we ended up with three discrete colors. This is because the values in the body_mass_g and species columns have different data types, which affect how R interacts with them.\n\n\n\n\n\n\nData Types\n\n\n\nA value’s data type determines how it’s stored in memory and what type of operations we can perform with it. R supports several basic variable types:\n\ndouble - A number or numeric type that has decimals. This is the default type for any number in R. We can use doubles with all arithmetic operators.\ninteger - A number without any decimal places. If we want an integer, we need to create one explicitly using a function like as.integer(). Integers also work with all arithmetic operators.\ncharacter - Text data, enclose by quotation marks, that can contain letters, numbers, and special characters. These are called “strings” in other programming languages. Characters are the most flexible type in terms of what they can store, but the don’t work with arithmetic operators.\nfactor - R’s representation of categorical data. These are similar to characters in that they can contain letters, numbers, and special characters. This also means it’s generally easy to make factors out of character data. When we create a factor variable or column , we define all possible categories, or “levels”, that variable/column can assume. There’s additional complexity to factors that we’ll get into later.\nlogical - A binary value that can only be TRUE or FALSE. We’ve seen logical values when we used the relational operators (e.g. ==, &gt;, !=). We can tell these apart from characters, because TRUE and FALSE aren’t surrounded by any quotation marks. Lastly, we can use these with arithmetic operators. TRUE is treated like 1, and FALSE is treated like 0\n\nWe can check the type of any object in R using the class() function.\n\n\nSpecies is a factor type while body mass is a numeric type. Factors are discrete variables, so ggplot2 maps them to discrete aesthetics. Numeric types are continuous variables, so ggplot2 cannot map them to discrete values.\nWe can use also use expressions as aesthetic mappings.\n\npenguins |&gt; \n    ggplot(aes(x = bill_length_mm,\n               y = flipper_length_mm,\n               color = bill_length_mm &gt; 45)) +\n    geom_point()\n\nWarning: Removed 2 rows containing missing values (`geom_point()`)."
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-03_Exploring-geom-functions-and-customizing-ggplots.html#mapping-vs-setting-aesthetics",
    "href": "LESSONS/COMPLETED/Completed_Lesson-03_Exploring-geom-functions-and-customizing-ggplots.html#mapping-vs-setting-aesthetics",
    "title": "Lesson 3: Exploring geom_ functions and customizing ggplots",
    "section": "3.3 Mapping vs Setting Aesthetics",
    "text": "3.3 Mapping vs Setting Aesthetics\nAbove we used the aes() function to map columns in our penguin data to the aesthetics in our plots. Let’s see what happens when we move the aesthetic arguments outside of the aes() function.\n\npenguins |&gt; \n    ggplot(aes(x = bill_length_mm,\n               y = flipper_length_mm)) +\n    geom_point(color = \"darkorange\")\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\nThis is called setting an aesthetic, because we’re not mapping any of our data to the aesthetic. When we set aesthetic arguments, we provide them with scalar values. The specific values will depend upon the aesthetic (i.e. some are numbers, some require known values).\nLook at the geom_point() documentation, and scroll down to the Aesthetics section. This lists all the different aesthetics this function supports. Try adding some of these aesthetics to the above plot, both in and out of the aes() function. Hint: we can print a list of R color constants with the colors() function.\n\npenguins |&gt; \n    ggplot(aes(x = bill_length_mm,\n               y = flipper_length_mm)) +\n    geom_point(alpha = 0.5,\n               color = \"#900C3F\")\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\nThis vignette from the ggplot package describes all of the aesthetics and the various values they can accept. We can find this vignette on the ggplot2 CRAN page, or by using the vignette() function.\n\nvignette(\"ggplot2-specs\")\n\n\n\n\n\n\n\nVignettes\n\n\n\nTutorials demonstrating the functionality of a package are called vignettes. They’re another way to familiarize ourselves with a new package. These are downloaded to your system when you install a package and are accessible through the package website (on CRAN or Bioconductor). Not every package comes with a vignette, since they are not a required by CRAN or Bioconductor."
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-03_Exploring-geom-functions-and-customizing-ggplots.html#bar-chart",
    "href": "LESSONS/COMPLETED/Completed_Lesson-03_Exploring-geom-functions-and-customizing-ggplots.html#bar-chart",
    "title": "Lesson 3: Exploring geom_ functions and customizing ggplots",
    "section": "4.1 Bar chart",
    "text": "4.1 Bar chart\nThe geom_bar() function generates bar charts, which are useful for plotting the distributions of categorical data. Let’s use this to get a breakdown of the number of COVID-19 tests by their result (positive, negative, invalid).\n\ncovid_testing |&gt; \n    ggplot(aes(x = result)) +\n    geom_bar()\n\n\n\n\nWhen we use the geom_bar() function, we only provide it with an aesthetic mapping for one of the axes (x or y). It automatically calculates the values for the other axis, based on the distribution of our data across the axis we specified."
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-03_Exploring-geom-functions-and-customizing-ggplots.html#histogram-freqpoly",
    "href": "LESSONS/COMPLETED/Completed_Lesson-03_Exploring-geom-functions-and-customizing-ggplots.html#histogram-freqpoly",
    "title": "Lesson 3: Exploring geom_ functions and customizing ggplots",
    "section": "4.2 Histogram & Freqpoly",
    "text": "4.2 Histogram & Freqpoly\nThe geom_histogram() function calculates discrete density bins, given just an x-coordinate mapping. Its useful for visualizing the distributions of continuous numerical variables. Let’s use the geom_histogram() function to plot the distribution of COVID-19 tests over the first 100 days of the covid_testing dataset.\n\ncovid_testing |&gt; \n    ggplot(aes(x = pan_day)) +\n    geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nNote, ggplot2 printed a status message with the histogram, pointing us toward two arguments for the geom_histogram() function: bins, and binwidth.\nThe bins argument controls the number of bins it groups our data into. The above plot sets the bins argument to a value of 30 (the default). Try adjusting it below. What do you think will happen to the graph if we increase the bins value? What if we decrease it?\n\ncovid_testing |&gt; \n    ggplot(aes(x = pan_day)) +\n    geom_histogram(bins = 60)\n\n\n\n\nAlternatively, we can use the binwidth argument to set the size of the interval on the x-axis that defines a bin. Whatever value we enter for the binwidth uses the same units as the x-axis (days, in our case). What do you think will happen to the histogram as we increase the binwidth? And if we decrease it?\n\ncovid_testing |&gt; \n    ggplot(aes(x = pan_day)) +\n    geom_histogram(binwidth = 1)\n\n\n\n\nThe geom_freqpoly() function generates the same discrete distribution graph as geom_histogram(), except it represents the data as lines, instead of bars.\n\ncovid_testing |&gt; \n    ggplot(aes(x = pan_day)) +\n    geom_freqpoly()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nYou can confirm these two functions work the same way by plotting them together. Try that here:\n\ncovid_testing |&gt; \n    ggplot(aes(x = pan_day)) +\n    geom_histogram() +\n    geom_freqpoly()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nThe line representation produced by geom_freqpoly() can make it easier to plot multiple distributions together.\n\ncovid_testing |&gt; \n    ggplot(aes(x = pan_day, color = result)) +\n    geom_freqpoly()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nFor comparison, here’s the same data plotted as a histogram:\n\ncovid_testing |&gt; \n    ggplot(aes(x = pan_day, fill = result)) +\n    geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`."
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-03_Exploring-geom-functions-and-customizing-ggplots.html#density",
    "href": "LESSONS/COMPLETED/Completed_Lesson-03_Exploring-geom-functions-and-customizing-ggplots.html#density",
    "title": "Lesson 3: Exploring geom_ functions and customizing ggplots",
    "section": "4.3 Density",
    "text": "4.3 Density\nThe geom_density() function generates a smoothed density estimate for the distribution of a continuous variable. This is similar to the histogram and freqpoly geoms, except those geoms generate binned representations of the distribution, while geom_density() generates a continuous representation of the distribution.\n\ncovid_testing |&gt; \n    ggplot(aes(x = pan_day)) +\n    geom_density()\n\n\n\n\nWe can think of this like a probability distribution estimate for all the possible values our x-axis variable can assume (the area under the curve should sum approximately to 1).\n\n\n\n\n\n\nThe after_stat() function\n\n\n\nWe can use the after_stat() function to access the derived stats that the geom_density() function is calculating behind the scenes. Here we use this function to change the y-value to the number of COVID-19 tests, instead of the density value.\n\ncovid_testing |&gt; \n    ggplot(aes(x = pan_day)) +\n    geom_density(aes(y = after_stat(count)))\n\n\n\n\nWe can refer to the the “Computed variables” section of a geom function’s help documentation to find the list of summary variables we can access with after_stat().\n\n\nHere we see that the geom_density() curve is effectively a smoothed version of the geom_freqpoly() line.\n\ncovid_testing |&gt; \n    ggplot(aes(x = pan_day)) +\n    geom_freqpoly(binwidth = 1) +\n    geom_density(aes(y = after_stat(count)))\n\n\n\n\nWhy do you think these curves diverge when we increase the ‘binwidth’ for geom_freqpoly()?\n\ncovid_testing |&gt; \n    ggplot(aes(x = pan_day)) +\n    geom_freqpoly(binwidth = 3) +\n    geom_density(aes(y = after_stat(count)))"
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-03_Exploring-geom-functions-and-customizing-ggplots.html#boxplot-violin-plot",
    "href": "LESSONS/COMPLETED/Completed_Lesson-03_Exploring-geom-functions-and-customizing-ggplots.html#boxplot-violin-plot",
    "title": "Lesson 3: Exploring geom_ functions and customizing ggplots",
    "section": "4.4 Boxplot & Violin plot",
    "text": "4.4 Boxplot & Violin plot\nThe geom_boxplot() function offers another way to summarize the distributions of continuous data. It calculates and plots the median and quartiles of a continuous variable mapped to the x or y aesthetic.\n\ncovid_testing |&gt; \n    ggplot(aes(y = age)) +\n    geom_boxplot()\n\n\n\n\nHowever, what makes boxplots truly useful is their ability to represent the relationship numerical and categorical variables. Here we break up the age distribution we plotted above, by COVID-19 test result.\n\ncovid_testing |&gt; \n    ggplot(aes(x = result, y = age)) +\n    geom_boxplot()\n\n\n\n\nLooking at these boxplots, we see a subtle indication that patients with positive COVID-19 tests tend to skew a little older than those with negative tests (we’ll need to actually apply a statistical test if we want to say anything more conclusive).\nViolin plots are a combination of the geom_boxplot() and geom_density() functions. The geom_violing() function plots a sideways, mirrored representation of a numeric variable’s distribution.\n\ncovid_testing |&gt; \n    ggplot(aes(x = result, y = age)) +\n    geom_violin()\n\n\n\n\nViolin plots can reveal more subtle differences in relationships between numerical and categorical variables than we can see with a boxplot, like biomodality in the underlying distributions.\nHere we’ll graph the geom_violin() and geom_boxplot() plots together. How are the boxplots and violin plots similar? How are they different?\n\ncovid_testing |&gt; \n    ggplot(aes(x = result, y = age)) +\n    geom_violin() +\n    geom_boxplot(alpha = 0.5)\n\n\n\n\nHere we used the alpha aesthetic to control the transparency of the boxplot geom. Try changing the alpha value to see how it affects the graph."
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-03_Exploring-geom-functions-and-customizing-ggplots.html#horizontal-and-vertical-lines",
    "href": "LESSONS/COMPLETED/Completed_Lesson-03_Exploring-geom-functions-and-customizing-ggplots.html#horizontal-and-vertical-lines",
    "title": "Lesson 3: Exploring geom_ functions and customizing ggplots",
    "section": "4.5 Horizontal and Vertical Lines",
    "text": "4.5 Horizontal and Vertical Lines\nThe geom_hline() and geom_vline() functions plot horizontal and vertical lines, respectively. They’re useful for marking cutoffs and regions of interest in our plots.\nHere we use geom_hline() to add a line to our age distribution boxplots that marks the division between patients under and over 5 years of age.\n\ncovid_testing |&gt; \n    ggplot(aes(x = result, y = age)) +\n    geom_violin() +\n    geom_hline(yintercept = 5)\n\n\n\n\nIn this case, we set the value for the yintercept aesthetic, rather than mapping it to a column in our data."
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-03_Exploring-geom-functions-and-customizing-ggplots.html#coordinate-transformations",
    "href": "LESSONS/COMPLETED/Completed_Lesson-03_Exploring-geom-functions-and-customizing-ggplots.html#coordinate-transformations",
    "title": "Lesson 3: Exploring geom_ functions and customizing ggplots",
    "section": "4.6 Coordinate Transformations",
    "text": "4.6 Coordinate Transformations\nThe coord_cartesian() function allows us to manually set the x- and y-axis ranges of our graphs. This allows us to focus on particular regions of interest.\n\ncovid_testing |&gt; \n    ggplot(aes(x = pan_day)) +\n    geom_histogram(binwidth = 1) +\n    coord_cartesian(xlim = c(10, NA),\n                    expand = FALSE)\n\n\n\n\nThe coord_flip() function allows us to swap the x- and y-axes.\n\ncovid_testing |&gt; \n    ggplot(aes(x = result, y = age)) +\n    geom_boxplot() +\n    coord_flip()\n\n\n\n\nThere are many more coord_ functions that give us fine control coordinate systems we use to create our ggplots."
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-03_Exploring-geom-functions-and-customizing-ggplots.html#setting-color-scales",
    "href": "LESSONS/COMPLETED/Completed_Lesson-03_Exploring-geom-functions-and-customizing-ggplots.html#setting-color-scales",
    "title": "Lesson 3: Exploring geom_ functions and customizing ggplots",
    "section": "4.7 Setting Color Scales",
    "text": "4.7 Setting Color Scales\nThus far we’ve just used the default color schemes ggplot2 provides. They’re fine for prototyping our analyses, but we’ll probably want to change these to something that looks better if we want to publish these figures. Now that you’ve gained some experience with the look and feel of the default settings for ggplot2 figures, you’ll start to notice them when you read papers.\nTo specify which colors get mapped to our data, we need to prepare a vector containing all of the colors we want to use.\n\ncolors_for_covid_result &lt;- c(\"grey\",\"dodgerblue\",\"orangered\")\n\n\n\n\n\n\n\nData Structures\n\n\n\nIn our work so far, we’ve largely worked with tabular data stored in a data frame. A data frame is an example of a data structure. These are constructs in a programming language that are specially designed to store and organize data. We’ll interact with several types of data structures over the course of these lessons:\n\nVectors: Store ordered sequences of values, all of which must have the same type. We create vectors using the c() function (“combine”). The individual values in a vector are called “vector elements”.\nData frame: Rectangular data structure where columns are vectors (i.e. all values in a column need to have the same type) that all have the same length.\nMatrix: Rectangular like a data frame, except every single values in a matrix must have the same type. We often store metadata (e.g. gene IDs, sample labels) as the row/column names, using the rownames() and colnames() functions. Matrices are used for performing matrix math and are often much faster for computations than data frames.\n\n\n\nWith our color vector in hand, we use the scale_fill_manual() function to match these colors to the three COVID-19 test results in our data. Try changing the result mapping from fill to color and see what happens.\n\ncovid_testing |&gt; \n    filter(age &lt; 100) |&gt; \n    ggplot(aes(x = result, y = age, fill = result)) +\n    geom_boxplot() +\n    scale_fill_manual(values = colors_for_covid_result)\n\n\n\n\nThe colors are assigned to the results in alphabetical order.\nInstead of manually specifying the colors, we can also use existing collections of colors (“palettes”) that come from various packages. On of the palettes packaged with ggplot2 is Color Brewer. We need to enter the name for one of Color Brewer’s palettes. We can view the options with the RColorBrewer::display.brewer.all() function.\n\ncovid_testing |&gt; \n    filter(age &lt; 100) |&gt; \n    ggplot(aes(x = result, y = age, fill = result)) +\n    geom_boxplot() +\n    scale_fill_brewer(palette = \"Dark2\")\n\n\n\n\nAnother way to view the Color Brewer palettes is through the Color Brewer website. There are many options on this site that can help you find a good palette, including a toggle to limit your options to colorblind safe options."
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-03_Exploring-geom-functions-and-customizing-ggplots.html#facets",
    "href": "LESSONS/COMPLETED/Completed_Lesson-03_Exploring-geom-functions-and-customizing-ggplots.html#facets",
    "title": "Lesson 3: Exploring geom_ functions and customizing ggplots",
    "section": "4.8 Facets",
    "text": "4.8 Facets\nWhen we’re plotting complex data, we often run into cases where it would be helpful to break up a figure into smaller sub-figures, each displaying a portion of the input data. We do this with the facet_grid() and facet_wrap() functions. In this example, we use facets to compare the distribution of ages by COVID-19 test results between the tests collected in the drive-thru or in the clinic.\n\ncovid_testing |&gt; \n    filter(age &lt; 100) |&gt; \n    ggplot(aes(x = result, y = age, fill = result)) +\n    geom_boxplot() +\n    scale_fill_manual(values = colors_for_covid_result) +\n    facet_wrap(facets = vars(drive_thru_ind))\n\n\n\n\nThe vars() function is like a version of the aes() function that’s specific to facet_wrap() and facet_grid(). They tell ggplot2 to map a variable from our dataset to the facets. You can think of the facet functions like graphical versions of the group_by() function we saw previously. They group data and aesthetics according to another variable in our data, and generate separate graph panels for the data in each group.\nFacets give use the ability to represent complex datasets with multiple variables in a more digestible manner. Here, we use facet_grid() to look for differences in age distributions by COVID-19 test results, across patient groups, and by whether or not the test samples as collected at a drive-thru.\n\ncovid_testing |&gt; \n    filter(age &lt; 100) |&gt; \n    ggplot(aes(x = result, y = age, fill = result)) +\n    geom_boxplot() +\n    scale_fill_manual(values = colors_for_covid_result) +\n    facet_grid(rows = vars(demo_group),\n               cols = vars(drive_thru_ind), scales = \"free_y\")"
  },
  {
    "objectID": "LESSONS/COMPLETED/Completed_Lesson-03_Exploring-geom-functions-and-customizing-ggplots.html#saving-ggplots",
    "href": "LESSONS/COMPLETED/Completed_Lesson-03_Exploring-geom-functions-and-customizing-ggplots.html#saving-ggplots",
    "title": "Lesson 3: Exploring geom_ functions and customizing ggplots",
    "section": "4.9 Saving ggplots",
    "text": "4.9 Saving ggplots\nSo far we’ve only created figures inside these markdown (Quarto) documents. We can render this file into an HTML or PDF output and then extract the images from the output file, but that’s a lot of extra work if we just want one figure. For ggplot2 figures, we can use the ggsave() function to save figures to files on disk. The help doc for ggsave() contains information about how we can control the dimensions, scale, resolution, and format of the saved figure. Here, we’ll save one of our faceted boxplot figures to the IMAGES/ directory as a PNG.\n\ncovid_figure &lt;- \n    covid_testing |&gt; \n    filter(age &lt; 100) |&gt; \n    # The \"0\" / \"1\" labels for the drive-thru status are not particularly clear.\n    # Here we create a new column with informative labels for drive-thru status.\n    # We'll use this new column for faceting, so the facet labels are clearer\n    # for potential readers.\n    mutate(\n        drive_thru_status =\n            case_match(drive_thru_ind,\n                       0 ~ \"In clinic\",\n                       1 ~ \"Drive-thru\")\n    ) |&gt; \n    ggplot(aes(x = result, y = age, fill = result)) +\n    geom_boxplot() +\n    scale_fill_manual(values = colors_for_covid_result) +\n    facet_grid(rows = vars(demo_group),\n               cols = vars(drive_thru_status),\n               scales = \"free_y\")\nggsave(filename = \"IMAGES/COVID-test-result-age-distribution_By-patient-group-and-drive-thru-status_Boxplots.png\",\n       plot = covid_figure,\n       units = \"in\",\n       width = 6,\n       height = 6)\n\nggsave() automatically saves the last plot we generated. Alternatively, we can save our ggplot graph to a variable, and pass that variable to the plot argument of the ggsave() function."
  }
]